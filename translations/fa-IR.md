# برگه تقلب جاوااسکریپت مدرن

_توضیح مترجم: اگر این سند را روی گیت‌هاب می‌بینید قطعا با مشکل نمایش چپ‌به‌راست شما را آزار می‌دهد. به منظور عدم ایجاد مشکل در ساختار پرونده مارک‌داون، از وارد کردن برچسب‌های html در این سند خودداری کرده‌ام. برای نمایش در جهت صحیح، می‌توانید این سند را روی نمونه‌های گیت‌لب مشاهده کنید. بد نیست بدانید نزدیک به ۵ سال است افراد مختلفی درخواست افزودن پشتیبانی از متن راست‌به‌چپ را به گیت‌هاب داده‌اند که با بی‌محلی کامل توسعه‌دهندگان این بستر انحصاری مواجه شده است. می‌توانید شما هم در این درخواست بی نتیجه ادامه دهید و یا این که به یک بستر آزاد انتشار کد مانند گیت‌لب مهاجرت کنید._

## مقدمه

### انگیزه

این سند، یک برگه تقلب برای مسائلی در جاوااسکپت است که به دفعات در کار با پروژه‌های مدرن و جدیدترین نمونه‌های کد با آن‌ها مواجه خواهید شد.

این راهنما قصد ندارد جاوااسکریپت را از بیخ آموزش بدهد بلکه می‌خواهد کمکی باشد برای دانش مقدماتی توسعه‌دهندگانی که ممکن است به واسطه مفاهیم جاوااسکریپت به کار برده شده در کدهای مدرن (مثلا در یادگیری ری‌اکت) با آن‌ها دست و پنجه نرم کنند.

در کنار این، تلاش می‌کنم گاهی نکاتی شخصی را ارائه دهم که ممکن است بحث برانگیز باشند اما هر کجا به آن‌ها اشاره کنم، بیان خواهم کرد که آن موارد، پیشنهادهای شخصی‌ام هستند.

> **نکته:** بیشتر مفاهمیمی که اینجا معرفی می‌شوند از به‌روزرسانی زبان جاوااسکریپت (ES2015 یا آن‌طور که معمولا گفته می‌شود ES6) می‌آیند. می‌توانید ویژگی‌های جدیدی که در این به‌روزرسانی اضافه شده‌اند را [این‌ جا](http://es6-features.org/) پیدا کنید که بسیار خوب ارائه شده‌اند.

## منابع مکمل

پیشنهاد می‌کنم وقتی در درک یک مفهوم دچار مشکل می‌شوید، در منابع زیر دنبال پاسخ بگردید:

- [MDN (Mozilla Developer Network)](https://developer.mozilla.org/en-US/search?q=)
- [You don't know JS (book)](https://github.com/getify/You-Dont-Know-JS)
- [Eloquent JavaScript (book)](https://eloquentjavascript.net)
- [Douglas Crockford's blog](https://www.crockford.com/javascript/)
- [ES6 Features with examples](http://es6-features.org)
- [Wes Bos blog (ES6)](http://wesbos.com/category/es6/)
- [Javascript Basics for Beginners](https://www.udacity.com/course/javascript-basics--ud804) - a free Udacity course
- [Reddit (JavaScript)](https://www.reddit.com/r/javascript/)
- [Google](https://www.google.com/) to find specific blog and resources
- [StackOverflow](https://stackoverflow.com/questions/tagged/javascript)

## فهرست مطالب

- [برگه تقلب جاوااسکریپت مدرن](#برگه-تقلب-جاوااسکریپت-مدرن)
  - [مقدمه](#مقدمه)
    - [انگیزه](#انگیزه)
    - [منابع مکمل](#منابع-مکمل)
  - [فهرست مطالب](#فهرست-مطالب)
  - [مفاهیم](#notions)
    - [اعلان متغیر: var، const، let](#اعلان-متغیر-var-const-let)
      - [توضیح کوتاه](#توضیح-کوتاه)
      - [نمونه کد](#نمونه-کد)
      - [توضیح مبسوط](#توضیح-مبسوط)
      - [منابع خارجی](#منابع-خارجی)

## مفاهیم

### اعلان متغیر: var، const، let

در جاوااسکریپت سه کلیدواژه برای اعلان یک متغیر وجود دارند که هر یک دارای ویژگی‌های خاص خود هستند. این کلیدواژه‌ها عبارت‌اند از `var` و `let` و `const`.

#### توضیح کوتاه

متغیرهایی که با `const` اعلان می‌شوند را نمی‌توان دوباره مقداردهی کرد در حالی که اگر همان متغیر با `var` یا `let` تعریف می‌شد، امکان این کار فراهم می‌بود.

پیشنهاد می‌کنم همیشه متغیرهای خود را به طور پیش‌فرض با `const` تعریف کنید مگر این که بخواهید آن را بعدا تغییر داده یا مقداردهی کنید که در این حالت پیشنهادم استفاده از `let` است.

|     |قلمرو|قابل مقداردهی|قابل تغییر|محدوده مرگ زمانی|
| --- | --- | --- | --- | --- |
|const|بلوک|خیر|بله|بله|
|let|بلوک|بله|بله|بله|
|var|تابع|بله|بله|خیر|

#### نمونه کد
```javascript
const person = "Nick";
person = "John" // خطایی اعلام می‌شود که مقدار متغییر نمی‌تواند تغییر کند
```

```javascript
let person = "Nick";
person = "John";
console.log(person) // "John", بازمقداردهی مجاز است
```

#### توضیح مبسوط
[قلمرو]() یک متغیر تقریبا به این معناست که «این متغیر در کجای کد قابل دسترس است».

##### استفاده از var
متغیرهایی که با `var` اعلان می‌شوند *در قلمروی تابع* دردسترس‌اند به این معنا که وقتی متغیری در یک تابع تعریف شود، هر چیزی در آن تابع می‌توان به آن متغیر دسترسی داشه باشد. در کنار این، یک متغیر *در قلمروی تابع* که داخل یک تابع تعریف شده است نمی‌تواند خارج از آن تابع در دسترس باشد.

پیشنهاد می‌کنم تصور کنید که یک متغیر *در قلمروی X* مانند آن است که آن متغیر، یکی خصوصیت (property) X باشد.


```javascript
function myFunction() {
  var myVar = "Nick";
  console.log(myVar); // "Nick" - متغیر داخل تابع در دسترس است
}
console.log(myVar); // ReferenceError - متغیر خارج از تابع در دسترس نیست
```
و این مثال:

```javascript
function myFunction() {
  var myVar = "Nick";
  if (true) {
    var myVar = "John";
    console.log(myVar); // "John"
    // چون متغیر در قلروی تابع است، مقدارش با مقدار جدید جایگزین می‌شود.
  }
  console.log(myVar); // "John" - ببینید که دستورات داخل شرط چه طور روی مقدار این متغیر اثر می‌گذارد
}
console.log(myVar); // ReferenceError - متغیر خارج از تابع در دسترس نیست
```

افزون بر این، متغییرهایی که توسط `var` اعلان می‌شوند به بالای قلمرو در زمان اجرا منتقل می‌گردند.این چیزی است که آن را [var hoisting](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting) می‌خوانیم.

این بخش از کد:

```js
console.log(myVar) // undefined -- no error raised
var myVar = 2;
```

در زمان اجرا به این شکل فهمیده می‌شود:

```js
var myVar;
console.log(myVar) // undefined -- no error raised
myVar = 2;
```

##### استفاده از let
شباهت‌هایی زیادی میان `let` و `var` وجود دارد اما متغیرهایی که با `let` تعریف می‌شوند:

- *در قلمروی بلوک* هستند
- پیش از مقداردهی قابل دسترسی **نیستند**
- نمی‌توانند در همان قلمرو بازاعلان شوند

بگذارید اثر تعریف متغیر در قلمروی بلوک را در همان مثال‌های پیشین ببینیم:

```javascript
function myFunction() {
  let myVar = "Nick";
  if (true) {
    let myVar = "John";
    console.log(myVar); // "John"
    // چون myVar یک متغیر در قلمروی بلوک است، در واقع یک متغیر جدید اعلان کرده‌ایم.
    // این متغیر خارج از این بلوک قابل دسترس نیست و در حقیقت، کاملا مستقل
    // از آن متغیر myVar است که اول تعریف شده بود.
  }
  console.log(myVar); // "Nick", ببینید که چه طور دستورات داخل شرط، تاثیری روی متغیر بیرون شرط ندارد
}
console.log(myVar); // ReferenceError - متغیر خارج از تابع قابل دسترس نیست
```

حال ببینیم که یعنی چه که متغیرهای `let` (و `const`) پیش از مقداردهی دسترسی نیستند:

```js
console.log(myVar) // ReferenceError !
let myVar = 2;
```

بر خلاف متغیرهای `var`، اگر تلاش کنید یک متغیر `let` یا `const` را پیش از مقداردهی بخوانید یا رویش بنویسید، خطا دریافت خواهید کرد. این پدیده معمولا با نام *محدوده مرگ زمانی* یا [*Temporal dead zone*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let) یا به اختصار *TDZ* خوانده می‌شود.

> **نکته:** از منظر فنی، اعلان‌های متغیر با `let` و `const` نیز بالاتر اجرا می‌شوند (hoist) اما مقداردهی‌شان نه. از همین رو که این گونه ساخته شده‌اند که تا پیش از مقداردهی، قابل استفاده نباشند این حس ایجاد می‌شود که گویی مورد hoist قرار نگرده‌اند در حالی که قرار گرفته‌اند. اگر می‌خواهید بیشتر بدانید، به [این توضیح بسیار مبسوط](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified) مراجعه کنید.

به علاوه، نمی‌توانید متغیرهای `let` را مجددا اعلان کنید:

```js
let myVar = 2;
let myVar = 3; // SyntaxError
```

##### استفاده از const

متغیرهای اعلان شده با `const` مشابه متغیرهای `let` رفتار می‌کنند با این تفاوت که قابل مقداردهی مجدد نیستند. به طور خلاصه، متغیرهای `const`:

- *در قلمروی بلوک* هستند
- پیش از مقداردهی قابل دسترسی نیستند
- نمی‌توانند در همان قلمرو بازاعلان شوند
- نمی‌توانند مقداردهی مجدد شوند

```js
const myVar = "Nick";
myVar = "John" // خطایی می‌بینید که مقداردهی مجدد ممکن نیست
```

```js
const myVar = "Nick";
const myVar = "John" // خطایی می‌بینید که اعلان مجدد ممکن نیست
```

اما یک نکته ظریف در این جا وجود دارد: متغیرهای `const` تغییرناپذیر یا immutable نیستند! به معنای دقیق‌تر، آرایه‌ها و شیءهایی که با `const` اعلان شده‌اند **می‌توانند** تغییر کنند.

برای شی‌ءها:

```js
const person = {
  name: 'Nick'
};
person.name = 'John' // کار می‌کند چون این متغیر کاملا مقداردهی نشده، می‌تواند تغییر کند
console.log(person.name) // "John"
person = "Sandra" // خطا دریافت خواهید کرد چون قابل مقداردهی مجدد نیست
```

برای آرایه‌ها:

```js
const person = [];
person.push('John'); // کار می‌کند چون این متغیر کاملا مقداردهی نشده، می‌تواند تغییر کند
console.log(person[0]) // "John"
person = ["Nick"] // خطا دریافت خواهید کرد چون قابل مقداردهی مجدد نیست
```

#### منابع خارجی


- [How let and const are scoped in JavaScript - WesBos](http://wesbos.com/javascript-scoping/)
- [Temporal Dead Zone (TDZ) Demystified](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified)
