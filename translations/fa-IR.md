# برگه تقلب جاوااسکریپت مدرن

_توضیح مترجم: اگر این سند را روی گیت‌هاب می‌بینید قطعا با مشکل نمایش چپ‌به‌راست شما را آزار می‌دهد. به منظور عدم ایجاد مشکل در ساختار پرونده مارک‌داون، از وارد کردن برچسب‌های html در این سند خودداری کرده‌ام. برای نمایش در جهت صحیح، می‌توانید این سند را روی نمونه‌های گیت‌لب مشاهده کنید. بد نیست بدانید نزدیک به ۵ سال است افراد مختلفی درخواست افزودن پشتیبانی از متن راست‌به‌چپ را به گیت‌هاب داده‌اند که با بی‌محلی کامل توسعه‌دهندگان این بستر انحصاری مواجه شده است. می‌توانید شما هم در این درخواست بی نتیجه ادامه دهید و یا این که به یک بستر آزاد انتشار کد مانند گیت‌لب مهاجرت کنید._

## مقدمه

### انگیزه

این سند، یک برگه تقلب برای مسائلی در جاوااسکپت است که به دفعات در کار با پروژه‌های مدرن و جدیدترین نمونه‌های کد با آن‌ها مواجه خواهید شد.

این راهنما قصد ندارد جاوااسکریپت را از بیخ آموزش بدهد بلکه می‌خواهد کمکی باشد برای دانش مقدماتی توسعه‌دهندگانی که ممکن است به واسطه مفاهیم جاوااسکریپت به کار برده شده در کدهای مدرن (مثلا در یادگیری ری‌اکت) با آن‌ها دست و پنجه نرم کنند.

در کنار این، تلاش می‌کنم گاهی نکاتی شخصی را ارائه دهم که ممکن است بحث برانگیز باشند اما هر کجا به آن‌ها اشاره کنم، بیان خواهم کرد که آن موارد، پیشنهادهای شخصی‌ام هستند.

> **نکته:** بیشتر مفاهمیمی که اینجا معرفی می‌شوند از به‌روزرسانی زبان جاوااسکریپت (ES2015 یا آن‌طور که معمولا گفته می‌شود ES6) می‌آیند. می‌توانید ویژگی‌های جدیدی که در این به‌روزرسانی اضافه شده‌اند را [این‌ جا](http://es6-features.org/) پیدا کنید که بسیار خوب ارائه شده‌اند.

## منابع مکمل

پیشنهاد می‌کنم وقتی در درک یک مفهوم دچار مشکل می‌شوید، در منابع زیر دنبال پاسخ بگردید:

- [MDN (Mozilla Developer Network)](https://developer.mozilla.org/en-US/search?q=)
- [You don't know JS (book)](https://github.com/getify/You-Dont-Know-JS)
- [Eloquent JavaScript (book)](https://eloquentjavascript.net)
- [Douglas Crockford's blog](https://www.crockford.com/javascript/)
- [ES6 Features with examples](http://es6-features.org)
- [Wes Bos blog (ES6)](http://wesbos.com/category/es6/)
- [Javascript Basics for Beginners](https://www.udacity.com/course/javascript-basics--ud804) - a free Udacity course
- [Reddit (JavaScript)](https://www.reddit.com/r/javascript/)
- [Google](https://www.google.com/) to find specific blog and resources
- [StackOverflow](https://stackoverflow.com/questions/tagged/javascript)

## فهرست مطالب

- [برگه تقلب جاوااسکریپت مدرن](#برگه-تقلب-جاوااسکریپت-مدرن)
  - [مقدمه](#مقدمه)
    - [انگیزه](#انگیزه)
    - [منابع مکمل](#منابع-مکمل)
  - [فهرست مطالب](#فهرست-مطالب)
  - [مفاهیم](#notions)
    - [اعلان متغیر: var، const، let](#اعلان-متغیر-var-const-let)
      - [توضیح کوتاه](#توضیح-کوتاه)
      - [نمونه کد](#نمونه-کد)
      - [توضیح مبسوط](#توضیح-مبسوط)
      - [منابع خارجی](#منابع-خارجی)
    - [تابع پیکانی](#تابع-پیکانی)
      - [نمونه کد](#نمونه-کد-1)
      - [توضیح مبسوط](#توضیح-مبسوط-1)
        - [اختصار](#اختصار)
        - [ارجاع this](#ارجاع-this)
      - [منابع مفید](#منابع-مفید)
    - [مقدار پیش‌فرض پارامتر تابع](#مقدار-پیشفرض-پارامتر-تابع)
      - [منابع خارجی](#منابع-خارجی-1)
    
## مفاهیم

### اعلان متغیر: var، const، let

در جاوااسکریپت سه کلیدواژه برای اعلان یک متغیر وجود دارند که هر یک دارای ویژگی‌های خاص خود هستند. این کلیدواژه‌ها عبارت‌اند از `var` و `let` و `const`.

#### توضیح کوتاه

متغیرهایی که با `const` اعلان می‌شوند را نمی‌توان دوباره مقداردهی کرد در حالی که اگر همان متغیر با `var` یا `let` تعریف می‌شد، امکان این کار فراهم می‌بود.

پیشنهاد می‌کنم همیشه متغیرهای خود را به طور پیش‌فرض با `const` تعریف کنید مگر این که بخواهید آن را بعدا تغییر داده یا مقداردهی کنید که در این حالت پیشنهادم استفاده از `let` است.

|     |قلمرو|قابل مقداردهی|قابل تغییر|محدوده مرگ زمانی|
| --- | --- | --- | --- | --- |
|const|بلوک|خیر|بله|بله|
|let|بلوک|بله|بله|بله|
|var|تابع|بله|بله|خیر|

#### نمونه کد
```javascript
const person = "Nick";
person = "John" // خطایی اعلام می‌شود که مقدار متغییر نمی‌تواند تغییر کند
```

```javascript
let person = "Nick";
person = "John";
console.log(person) // "John", بازمقداردهی مجاز است
```

#### توضیح مبسوط
[قلمرو]() یک متغیر تقریبا به این معناست که «این متغیر در کجای کد قابل دسترس است».

##### استفاده از var
متغیرهایی که با `var` اعلان می‌شوند *در قلمروی تابع* دردسترس‌اند به این معنا که وقتی متغیری در یک تابع تعریف شود، هر چیزی در آن تابع می‌توان به آن متغیر دسترسی داشه باشد. در کنار این، یک متغیر *در قلمروی تابع* که داخل یک تابع تعریف شده است نمی‌تواند خارج از آن تابع در دسترس باشد.

پیشنهاد می‌کنم تصور کنید که یک متغیر *در قلمروی X* مانند آن است که آن متغیر، یکی خصوصیت (property) X باشد.


```javascript
function myFunction() {
  var myVar = "Nick";
  console.log(myVar); // "Nick" - متغیر داخل تابع در دسترس است
}
console.log(myVar); // ReferenceError - متغیر خارج از تابع در دسترس نیست
```
و این مثال:

```javascript
function myFunction() {
  var myVar = "Nick";
  if (true) {
    var myVar = "John";
    console.log(myVar); // "John"
    // چون متغیر در قلروی تابع است، مقدارش با مقدار جدید جایگزین می‌شود.
  }
  console.log(myVar); // "John" - ببینید که دستورات داخل شرط چه طور روی مقدار این متغیر اثر می‌گذارد
}
console.log(myVar); // ReferenceError - متغیر خارج از تابع در دسترس نیست
```

افزون بر این، متغییرهایی که توسط `var` اعلان می‌شوند به بالای قلمرو در زمان اجرا منتقل می‌گردند.این چیزی است که آن را [var hoisting](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting) می‌خوانیم.

این بخش از کد:

```js
console.log(myVar) // undefined -- no error raised
var myVar = 2;
```

در زمان اجرا به این شکل فهمیده می‌شود:

```js
var myVar;
console.log(myVar) // undefined -- no error raised
myVar = 2;
```

##### استفاده از let
شباهت‌هایی زیادی میان `let` و `var` وجود دارد اما متغیرهایی که با `let` تعریف می‌شوند:

- *در قلمروی بلوک* هستند
- پیش از مقداردهی قابل دسترسی **نیستند**
- نمی‌توانند در همان قلمرو بازاعلان شوند

بگذارید اثر تعریف متغیر در قلمروی بلوک را در همان مثال‌های پیشین ببینیم:

```javascript
function myFunction() {
  let myVar = "Nick";
  if (true) {
    let myVar = "John";
    console.log(myVar); // "John"
    // چون myVar یک متغیر در قلمروی بلوک است، در واقع یک متغیر جدید اعلان کرده‌ایم.
    // این متغیر خارج از این بلوک قابل دسترس نیست و در حقیقت، کاملا مستقل
    // از آن متغیر myVar است که اول تعریف شده بود.
  }
  console.log(myVar); // "Nick", ببینید که چه طور دستورات داخل شرط، تاثیری روی متغیر بیرون شرط ندارد
}
console.log(myVar); // ReferenceError - متغیر خارج از تابع قابل دسترس نیست
```

حال ببینیم که یعنی چه که متغیرهای `let` (و `const`) پیش از مقداردهی دسترسی نیستند:

```js
console.log(myVar) // ReferenceError !
let myVar = 2;
```

بر خلاف متغیرهای `var`، اگر تلاش کنید یک متغیر `let` یا `const` را پیش از مقداردهی بخوانید یا رویش بنویسید، خطا دریافت خواهید کرد. این پدیده معمولا با نام *محدوده مرگ زمانی* یا [*Temporal dead zone*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let) یا به اختصار *TDZ* خوانده می‌شود.

> **نکته:** از منظر فنی، اعلان‌های متغیر با `let` و `const` نیز بالاتر اجرا می‌شوند (hoist) اما مقداردهی‌شان نه. از همین رو که این گونه ساخته شده‌اند که تا پیش از مقداردهی، قابل استفاده نباشند این حس ایجاد می‌شود که گویی مورد hoist قرار نگرده‌اند در حالی که قرار گرفته‌اند. اگر می‌خواهید بیشتر بدانید، به [این توضیح بسیار مبسوط](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified) مراجعه کنید.

به علاوه، نمی‌توانید متغیرهای `let` را مجددا اعلان کنید:

```js
let myVar = 2;
let myVar = 3; // SyntaxError
```

##### استفاده از const

متغیرهای اعلان شده با `const` مشابه متغیرهای `let` رفتار می‌کنند با این تفاوت که قابل مقداردهی مجدد نیستند. به طور خلاصه، متغیرهای `const`:

- *در قلمروی بلوک* هستند
- پیش از مقداردهی قابل دسترسی نیستند
- نمی‌توانند در همان قلمرو بازاعلان شوند
- نمی‌توانند مقداردهی مجدد شوند

```js
const myVar = "Nick";
myVar = "John" // خطایی می‌بینید که مقداردهی مجدد ممکن نیست
```

```js
const myVar = "Nick";
const myVar = "John" // خطایی می‌بینید که اعلان مجدد ممکن نیست
```

اما یک نکته ظریف در این جا وجود دارد: متغیرهای `const` تغییرناپذیر یا immutable نیستند! به معنای دقیق‌تر، آرایه‌ها و شیءهایی که با `const` اعلان شده‌اند **می‌توانند** تغییر کنند.

برای شی‌ءها:

```js
const person = {
  name: 'Nick'
};
person.name = 'John' // کار می‌کند چون این متغیر کاملا مقداردهی نشده، می‌تواند تغییر کند
console.log(person.name) // "John"
person = "Sandra" // خطا دریافت خواهید کرد چون قابل مقداردهی مجدد نیست
```

برای آرایه‌ها:

```js
const person = [];
person.push('John'); // کار می‌کند چون این متغیر کاملا مقداردهی نشده، می‌تواند تغییر کند
console.log(person[0]) // "John"
person = ["Nick"] // خطا دریافت خواهید کرد چون قابل مقداردهی مجدد نیست
```

#### منابع خارجی


- [How let and const are scoped in JavaScript - WesBos](http://wesbos.com/javascript-scoping/)
- [Temporal Dead Zone (TDZ) Demystified](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified)

### تابع پیکانی

در به‌روزرسانی ES6 جاوااسکریپت، *توابع پیکانی* یا Arrow Function معرفی شدند که روشی دیگری برای اعلان و استفاده از توابع هستند. برخی از فواید این نوع توابع عبارت‌اند از:

- مختصرتر هستند
- مقدار *this* از محیط برداشته می‌شود
- بازگشت تلویحی

#### نمونه کد

- اختصار و بازگشت تلویحی

```js
function double(x) { return x * 2; } // روش سنتی
console.log(double(2)) // 4
```

```js
const double = x => x * 2; // همان تابع به صورت تابع پیکانی با مقدار بازگشتی تلویحی
console.log(double(2)) // 4
```

- ارجاع *this*

در تابع پیکانی، *this* معادل مقدار *this* در بافتار اجرای محاط بر تابع است. اساسا با توابع پیکانی شما نیازی به ترفند `that = this` پیش از فراخوانی تابع دیگری داخل یک تابع ندارید.

```js
function myFunc() {
  this.myVar = 0;
  setTimeout(() => {
    this.myVar++;
    console.log(this.myVar) // 1
  }, 0);
}
```

#### توضیح مبسوط

##### اختصار

توابع پیکانی در قیاس با توابع سندی به روش‌های زیادی مختصرتر هستند. بگذارید همه حالت‌های ممکن را مرور کنیم:

- بازگشت تصریحی در مقابل تلویحی

**بازگشت تصریحی** تابعی است که در آن کلیدواژه *return* در بدنه تابع استفاده شده باشد.

```js
  function double(x) {
    return x * 2; // صریحا از کلیدواژه بازگشت استفاده شده است
  }
```

در روش سنتی نوشتن تابع، بازگشت همیشه صریح بوده است. اما با توابع پیکانی، می‌توانید *بازگشت تلویحی* داشه باشید که یعنی برای بازگرداندن یک مقدار، نیازی به استفاده از کلیدواژه *return* ندارید.

```js
  const double = (x) => {
    return x * 2; // بازگشت صریح
  }
```

از آن جایی که این تابع فقط چیزی را بر می‌گرداند (فاقد هر گونه دستورالعملی پیش از کلیدواژه *return* است) می‌توانیم از بازگشت تلویحی استفاده کنیم.

```js
  const double = (x) => x * 2;
```

برای این منظور کافی است که کلیدواژه **return** و **گیومه‌ها را برداریم**. به همین دلیل است که این روش، بازگشت *تلویجی* خوانده می‌شود. کلیدواژه *return* وجود ندارد اما این تابع در واقع مقدار `x * 2` را برمی‌گرداند.

> **توجه:** اگر تابع شما مقداری (با *اثر جانبی*) بر نمی‌گرداند، در حقیقت بازگشت تلویحی یا تصریحی انجام نمی‌دهد.

در کنار این، اگر شما بخواهید تلویحا یک *شیء* را برگردانید **لازم است که آن را در پرانتز قرار دهید** چون در غیر این صورت، با آکولادهای بلوک دچار تداخل می‌شود.

```js
const getPerson = () => ({ name: "Nick", age: 24 })
console.log(getPerson()) // { name: "Nick", age: 24 } -- شیء به صورت تلویحی با کمک تابع پیکانی بازگشت داده شده است
```

- تنها یک آرگومان

اگر تابع شما تنها یک پارامتر دریافت می‌کند می‌توانید پرانتز را از اطراف آن بردارید. اگر کد **double** بالایی را در نظر بگیریم:

```js
  const double = (x) => x * 2; // این تابع پیکانی تنها یک پارامتر دریافت می‌کند
```

پرانتزهای اطراف پارامتر می‌توانند برداشته شوند.

```js
  const double = x => x * 2; // این تابع پیکانی تنها یک پارامتر دریافت می‌کند
```

- بدون آرگومان

وقتی ورودی‌ای به تابع پیکانی وجود ندارد باید یک جفت پرانتز وارد کنید مگر نه خطای نحوی دریافت خواهید کرد.

```js 
  () => {
   // پرانتز درج شده و همه چیز درست کار می‌کند
    const x = 2;
    return x;
  }
```

```js
  => {
   // پرانتز درج نشده و کد اجرا نخواهد شد
    const x = 2;
    return x;
  }
```

##### ارجاع *this*

برای درک این ویژگی تازه معرفی شده همراه توابع پیکانی لازم است بدانید که **this** چگونه در جاوااسکریپت رفتار می‌کند.

در یک تابع پیکانی، *this* معادل *this* در بافتار اجرایی محاط بر تابع است. این یعنی که تابع پیکانی به جای ایجاد یک *this* جدید، آن را از محیطی که در آن احاطه شده می‌قاپد.

بدون تابع پیکانی اگر شما بخواهید از طریق *this* به یک متغیر در تابعی داخل یک تابع دسترسی پیدا کنید لازم است که از ترفند *that = this* یا *self = this* استفاده کنید.

به عنوان مثال، استفاده کردن از تابع setTimeout داخل تابع myFunc:

```js
function myFunc() {
  this.myVar = 0;
  var that = this; // that = this trick
  setTimeout(
    function() { // یک‫ this جدید در قلمروی این تابع ساخته می‌شود
      that.myVar++;
      console.log(that.myVar) // 1

      console.log(this.myVar) // undefined -- اعلان تابع را ببینید
    },
    0
  );
}
```

اما با تابع پیکانی، *this* از محیط پیرامونی‌اش گرفته می‌شود:

```js
function myFunc() {
  this.myVar = 0;
  setTimeout(
    () => {
    // اینجا this از محیط پیرامونی‌اش یعنی تابع myFunc گرفته می‌شود
      this.myVar++;
      console.log(this.myVar) // 1
    },
    0
  );
}
```

#### منابع مفید

- [Arrow functions introduction - WesBos](http://wesbos.com/arrow-functions/)
- [JavaScript arrow function - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)
- [Arrow function and lexical *this*](https://hackernoon.com/javascript-es6-arrow-functions-and-lexical-this-f2a3e2a5e8c4)


### مقدار پیش‌فرض پارامتر تابع

از به‌روزرسانی ES2015 جاوااسکریپت می‌توانید با نحو زیر، مقدار پیش‌فرض برای پارامترهای تابع تنظیم کنید:

```js
function myFunc(x = 10) {
  return x;
}
console.log(myFunc()) // 10
console.log(myFunc(5)) // 5

console.log(myFunc(undefined)) // 10
console.log(myFunc(null)) // null
```

پارامتر پیش‌فرض تنها در دو و فقط دو موقعیت اعمال می‌شود:

- پارامتری ارائه نشده باشد
- پارامتر *undefined* ارائه شده باشد

به بیان دیگر، اگر مقدار *null* را به پارامتر پیش‌فرض بدهید، این مقدار **اعمال نخواهد شد**.

> **نکته:** تخصیص مقدار پیش‌فرض می‌تواند با پارامترهای destructured هم استفاده شود (مفهوم بعدی را برای مثال ببینید)

#### منابع خارجی

- [Default parameter value - ES6 Features](http://es6-features.org/#DefaultParameterValues)
- [Default parameters - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters)

### تجزیه اشیاء و آرایه‌ها

*تجزیه* (destructuring) روشی آسان برای ساخت متغیرهای جدید از راه استخراج مقادیر از داده‌های ذخیره شده در اشیاء یا آرایه‌هاست.

به عنوان مثال، *تجزیه کردن* می‌تواند به منظور تجزیه پارامترهای تابع و یا *this.props* در پروژه‌های ری‌اکت مورد استفاده قرار گیرد.

#### توضیح با مثال

- شیء

بگذارید شیء زیر را برای تمام مثال‌ها در نظر بگیریم:

```js
const person = {
  firstName: "Nick",
  lastName: "Anderson",
  age: 35,
  sex: "M"
}
```

بدون تجزیه کردن:

```js
const first = person.firstName;
const age = person.age;
const city = person.city || "Paris";
```

با تجزیه کردن، تماما در یک خط:

```js
const { firstName: first, age, city = "Paris" } = person; // همین و بس

console.log(age) // 35 -- ‫متغیر جدید age ساخته شده و معادل است با person.age 
console.log(first) // "Nick" -- ‫متغیر جدید first ساخته شده و معادل است با person.firstName
console.log(firstName) // ReferenceError -- ‫در واقع person.firstName وجود دارد اما نام متغیر جدیدی که ساخته شده،first است
console.log(city) // "Paris" -- ‫متغیر جدیدی به نام city ساخته شده است اما چون person.city تغیرنشده است، مقدار موجود در city برابر است با مقدار پیش‌فرض ارائه شده یعنی Paris
```

**نکته:** آکولادهای استفاده شده در `const { age } = person` بعد از *const* نه برای اعلان شیء یا بلوک بلکه به عنوان نحو تجزیه نوشته شده است.

- پارامترهای تابع

*تجزیه کردن* معمولا برای تجزیه پارامترهای شیء در توابع استفاده می‌شود.

بدون تجزیه کردن

```js
function joinFirstLastName(person) {
  const firstName = person.firstName;
  const lastName = person.lastName;
  return firstName + '-' + lastName;
}

joinFirstLastName(person); // "Nick-Anderson"
```

با تجزیه کردن پارامتر *person* شیء، ما به یک تابع جمع و جورتر دست پیدا می‌کنیم:

```js
function joinFirstLastName({ firstName, lastName }) { // ‫ما متغیرهای firstName و lastName را با تجزیه پارامترهای شیء person به دست می‌آوریم
  return firstName + '-' + lastName;
}

joinFirstLastName(person); // "Nick-Anderson"
```

استفاده از تجزیه به خصوص در زمان استفاده از توابع پیکانی، شیرین‌تر هم می‌شود:

```js
const joinFirstLastName = ({ firstName, lastName }) => firstName + '-' + lastName;

joinFirstLastName(person); // "Nick-Anderson"
```

